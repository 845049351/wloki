'''Module for UCloud API'''

from __future__ import print_function
import os
import json
from tornado.httpclient import HTTPClient
from tornado.httpclient import HTTPRequest
from hashlib import sha1
from datetime import datetime, timedelta
from .common import read_json
from .common import ProviderError

try:
    from urllib.parse import urlencode
except ImportError:
    from urllib import urlencode

CONFIG_FILE = os.path.join(os.path.abspath(os.path.dirname(__file__)), 'credentials.json')


class UCloudError(ProviderError):
    '''Error contacting UCloud API'''


class UCloud(object):

    _config = read_json(CONFIG_FILE)['ucloud']
    _api = 'https://api.ucloud.cn/'
    _private_key = _config['private_key']
    _public_key = _config['public_key']
    _domain_id = 'ucdn-rt212d'  # m.wdjcdn.com
    _base_params = {'PublicKey': _public_key}

    def _sign(self, params):
        sig_string = ''.join('%s%s' % i for i in sorted(params.items()))
        sig_string += self._private_key
        sig = sha1(sig_string.encode()).hexdigest()
        return sig

    def _req(self, params, sig):
        params.update({'Signature': sig})
        req = HTTPRequest(
            url='{}?{}'.format(self._api, urlencode(params)),
            request_timeout=10,
            validate_cert=False
        )
        http = HTTPClient()
        resp = http.fetch(req)
        return resp

    def _get_domain_bandwidth(self, date):

        params = self._base_params.copy()
        begin_time = datetime.strptime(date, '%Y-%m-%d')
        end_time = begin_time + timedelta(seconds=86399)  # 86400 - 1
        print('Getting metrics from {} to {}'.format(begin_time, end_time))
        params.update({
            'Action': 'GetUcdnDomainBandwidth',
            'BeginTime': begin_time.strftime('%s'),
            'EndTime': end_time.strftime('%s')
        })
        sig = self._sign(params)
        resp = self._req(params, sig)
        if resp.error:
            raise UCloudError(resp.error.args)
        apidata = json.loads(resp.body.decode('utf-8'))
        if apidata['RetCode'] != 0:
            raise UCloudError
        else:
            data = apidata['BandwidthSet']
        return data

    def get_domain_bandwidth(self, start_date, end_date):

        d1 = datetime.strptime(start_date, '%Y-%m-%d')
        d2 = datetime.strptime(end_date, '%Y-%m-%d')
        dates = ((d2 - timedelta(i)).strftime('%Y-%m-%d') for i in range((d2 - d1).days, -1, -1))
        data = []
        for date in dates:
            data += self._get_domain_bandwidth(date)

        # Preprocess data for OpenTSDB
        payload = [(d['Time'], d['Value']) for d in data]
        payload = list(set(payload))
        payload.sort()
        return payload

    def refresh_domain_cache(self, url_list, url_type='file'):

        # Validate URL list
        if len(url_list) > 30:
            raise UCloudError('URL list too long. Required: <= 30')
        for url in url_list:
            if not url.startswith('http://'):
                raise UCloudError('URLs must start with "http://"')
            if url_type == 'dir' and not url.endswith('/'):
                raise UCloudError('Directory URLs must end with "/"')
            if url_type == 'file' and url.endswith('/'):
                raise UCloudError('File URLs must not end with "/"')

        params = self._base_params.copy()
        params.update({
            'DomainId': self._domain_id,
            'Type': url_type,
            'Action': 'RefreshUcdnDomainCache'
        })
        for url in url_list:
            key_name = 'UrlList.{}'.format(url_list.index(url))
            params.update({key_name: url})
        sig = self._sign(params)
        resp = self._req(params, sig)
        if resp.error:
            raise UCloudError(resp.error.args)
        apidata = json.loads(resp.body.decode('utf-8'))

        result_tpl = '''Purge tasks submitted. UCloud returns:
        Action: {}
        Return code: {}
        Task ID: {}'''
        result_msg = result_tpl.format(
            apidata.get('Action'),
            apidata.get('RetCode'),
            apidata.get('TaskId')
        )
        return result_msg
