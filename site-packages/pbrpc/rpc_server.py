from gevent import monkey; monkey.patch_socket()
import os
import utils
import gevent

from gevent import socket
from log import logger as log
from gevent.server import StreamServer
from gevent.lock import Semaphore
from rpc_pb2 import WirePayload, RpcResponse, SIMPLE
from rpc_controller import RpcController
from rpc_channel import Callback

class RpcConn(object):
    def __init__(self, sck, server):
        self._sck = sck
        self._rlock = Semaphore()
        self._wlock = Semaphore()
        self._server = server
        self._living_controllers = {}

    def on_reqeust(self, request):
        service = self.get_service(request.service_identifier)
        if service == None:
            return

        method = self.get_service_method(service, request.method_identifier)
        if method == None:
            return

        proto_request = self.get_proto_request(service, method, request)

        req_id = request.call_id
        controller = RpcController()
        self._living_controllers[req_id] = controller

        g = gevent.spawn(self.call_method_and_reply, req_id, service, method, controller, proto_request)
        g.start()

    def call_method_and_reply(self, req_id, service, method, controller, proto_request):
        callback = Callback()
        service.CallMethod(method, controller, proto_request, callback)

        if controller.IsCanceled():
            del self._living_controllers[req_id]
            return

        payload = WirePayload()
        if callback.response != None and controller.Failed() == False:
            resp = RpcResponse()
            resp.response_bytes = callback.response.SerializeToString()
            resp.call_id = req_id

            payload.rpc_response.call_id = req_id
            payload.rpc_response.response_bytes = resp.response_bytes
        else:
            if controller.Failed():
                payload.rpc_error.call_id = req_id
                payload.rpc_error.error = controller.ErrorText()

        buf = payload.SerializeToString()

        self._wlock.acquire()
        self._sck.sendall(utils.int32_to_bytes(len(buf)) + buf)
        self._wlock.release()

        # finish this call
        del self._living_controllers[req_id]

    def on_cancel(self, rpc_cancel):
        controller = self._living_controllers.get(rpc_cancel.call_id_to_cancel)
        if controller != None:
            controller.StartCancel()

    def get_service(self, service_name):
        service = self._server._serivces.get(service_name)
        return service

    def get_service_method(self, service, method_name):
        method = service.DESCRIPTOR.FindMethodByName(method_name)
        return method

    def get_proto_request(self, service, method, request):
        proto_request = service.GetRequestClass(method)()
        proto_request.ParseFromString(request.request_bytes)

        # Check the request parsed correctly
        if not proto_request.IsInitialized():
            return None

        return proto_request

    def run(self):
        while True:
            # read payload package
            self._rlock.acquire()
            sz = utils.read_int32(self._sck)
            if sz == None:
                self._rlock.release()
                break
            buf = utils.readall(self._sck, sz)
            if buf == None:
                self._rlock.release()
                break
            self._rlock.release()

            payload = WirePayload()
            payload.ParseFromString(buf)

            # if has rpc request
            if payload.rpc_cancel.IsInitialized():
                self.on_cancel(payload.rpc_cancel)
            elif payload.rpc_request.IsInitialized():
                self.on_reqeust(payload.rpc_request)


class RpcServer(object):
    def __init__(self, host, port):
        self._server = None
        self._serivces = {}
        self._addr = (host, port)
        self._conn = None

    def add_service(self, service):
        self._serivces[service.GetDescriptor().full_name] = service

    def handshake(self, sck):
        # read conn request
        payload = utils.read_payload_response(sck)
        log.debug(payload)

        resp = WirePayload()
        resp.connect_response.auth_method.append(SIMPLE)
        resp.connect_response.protocol = "text"
        resp.connect_response.server_name = socket.gethostname()
        utils.send_payload(sck, resp)
        payload = utils.read_payload_response(sck)
        if not payload.initial_auth_request.IsInitialized():
            return False

        resp = WirePayload()
        resp.auth_response.complete = True
        resp.auth_response.challenge = ""
        resp_buf = resp.SerializeToString()
        utils.send_payload(sck, resp)
        payload = utils.read_payload_response(sck)
        if not payload.properties_request.IsInitialized():
            return False

        resp = WirePayload()
        resp.properties_response.server_pid = str(os.getpid())
        utils.send_payload(sck, resp)

        return True

    def on_conn(self, sck, addr):
        if self.handshake(sck) == False:
            sck.close()
            return

        conn = RpcConn(sck, self)
        conn.run()
        sck.close()

    def run(self):
        self._server = StreamServer(self._addr, self.on_conn)
        self._server.serve_forever()

